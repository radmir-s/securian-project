# -*- coding: utf-8 -*-
"""GMAB model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1snEmTRPCvyOa-3qyIuUSkKhM-KI_eFnD

Notes about code specification:

1. Annuities are represented as "contracts"
* Contracts are functions that thate take [0] a tuple of external parameters (market performance, etc) and [1:] internal parameters (fund value, expense charge, etc)
* Contracts return a tuple containing [0] the present value (at time t_now) of the inflows and outflows to the insurance company for given external parameters and [1] the nominal value of the account at the end of the contract [2] the present value (at time t_now) of what would be a dollar at time t_max
* More complex contracts are expressed in terms of simpler contracts

2. For a given contract, we can compute the "greeks", which represent how the value of a contract changes with respect to a bump in an external parameter
* A greek is a function that takes [0] a tuple of external parameters, [1] some parameters indicating size and placement of the bump and [2] the contract and its parameters
* Greeks return [0] the change in the present value and [1,2] filler return values of 'None'
* Because greeks return a present value, we can compose them to get higher order derivatives - the filler return values are for backwards compatibility with the return type of contracts

3. For a given contract or greek, a "valuation" is a function that allows us to compute the value to a certain degree of precision. 
* The function value_by_rep takes [0] a tuple of external parameters, [1] a number of iterations to simulate the value of [2] a contract with [3] given arguments.
* The function value_by_error takes [0] a tuple of external parameters, [1] a standard deviation size for the estimate of [2] a contract with [3] given arguments.
* The function value_by precision takes [0] a tuple of external parameters, [1] a confidence level C, [2] a precision P, [3] a contract and [4] its arguments. Given C=.95 and P=.01 This function simulates the value until the 95% confidence interval for the value is within 1% of the estimated value.
* Valuations return a "sample datum", which is a tuple of external parameters [0] stock value and [1] risk-free interest rate, [2] a type of quantity (present value, delta, rho, etc) [3] MC-estimated value for the quatity under the given external params, [4] the standard deviation of the sample distribution for the estimated quantity and [5] the number of samples of the contract or greek required to produce that precision
* Note that [5] number of samples is not strictly comparable across contracts: obtaining one sample of a first-order greek requires ~2x the computation as obtaining one sample of a the value of the underlying contract.

4. For a given set of sample data, we can use an "interpolation scheme" to make a "model" of the data.
* An interpolation scheme is a function that takes as input [0] a list of sample data.
* The output of an interpolation scheme is a model.
* A model is a function that takes external parameters [0] stock value and [1] risk-free interest rate and outputs [0] an estimate for a quantity. The type of quantity (value, delta, rho, etc) is a fixed feature of the model.
"""



import math
import numpy as np
import scipy as sp
from scipy import signal
import itertools as it
import functools as ft
import operator as op
import matplotlib.pyplot as plt
import numba
import scipy.stats as st
import multiprocessing as mp
import types
import csv
from ast import literal_eval

N = 10000

# model params
t_now = 0
t_max = 10 # t in years
dt = 1/252
r = .03 * np.ones(int(t_max/dt))

# equity params
sig2 = .18**2
eZ = None
S0 = 1
S = None if eZ is None else S0 * np.multiply.accumulate(eZ)

# account params
t_begin = 0
t_end = t_max
A_now = 1
A = A_now * np.ones(int(t_max/dt) + 1)
cr = .01  # crediting rate
ec = .04  # expense ratio
rc = .04  # rider charge

# zipped model arguments
world_args = t_now, t_max, dt, r, sig2, eZ, S0, S

vec_roll_args = t_end, A, ec
vec_GMAB_args = t_begin, t_end, A, ec, rc, cr
vec_GMAB_ratchet_args = t_begin, t_end, A, ec, rc, cr

@numba.njit()
def set_world(world_args):
    t_now, t_max, dt, r, sig2, eZ, S0, S = world_args

    if eZ is None:
      Z = np.random.standard_normal(int(t_max/dt))
      eZ = np.exp((r-sig2/2) * dt +  math.sqrt(sig2*dt) * Z)
      S = S0 * np.ones(int(t_max/dt) + 1)
      for j in range(1, int(t_max/dt) + 1):
        S[j] = S[j-1] * eZ[j-1]
    if S is None:
      S = S0 * np.ones(int(t_max/dt) + 1)
      for j in range(1, int(t_max/dt) + 1):
        S[j] = S[j-1] * eZ[j-1]

    return t_now, t_max, dt, r, sig2, eZ, S0, S


'''VECTORIZED CONTRACTS'''

@numba.njit()
def compute_inflow(t_begin, dt, r, t_end, A, ec):
  dec = ec * dt
  inflow = 0
  val_now = 1
  for j in range(int(t_begin/dt), int(t_end/dt)):
    val_now /= (1 + r[j]*dt)
    inflow += A[j] * dec * val_now
  
  return inflow, val_now

# standard rollforward
@numba.njit()
def vec_rollforward(world_args, t_begin, t_end, A, ec):

  t_now, t_max, dt, r, sig2, eZ, S0, S = set_world(world_args)
  A_t = A * 1 # issues with mutability
  dec = ec * dt

  for j in range(int(t_begin/dt)+1, int(t_end/dt)+1):
    A_t[j] = A_t[j-1] * (eZ[j-1] - dec)
  inflow, val_end = compute_inflow(t_begin, dt, r, t_end, A_t, ec)
    
  return inflow, A_t, val_end

# GMAB without ratchet
@numba.njit()
def vec_GMAB(world_args, t_begin, t_end, A, ec, rc, cr):

  inflow, A_t, val_end = vec_rollforward(world_args, t_begin, t_end, A, ec+rc)

  guarantee = A_t[int(t_begin/dt)] * (1+cr)**(t_end - t_begin)
  rider_val = - max(guarantee - A_t[int(t_end/dt)], 0) * val_end

  return inflow + rider_val, A_t, val_end

# VA with accumulation benefit and ratchet.
# accumulation and ratchet operate independently (ratchet doesn't then accumulate)
@numba.njit()
def vec_GMAB_ratchet(world_args, t_begin, t_end, A, ec, rc, cr):

  inflow, A_t, val_end = vec_rollforward(world_args, t_begin, t_end, A, ec+rc)

  accum_guarantee =  A_t[int(t_begin/dt)] * math.pow(1 + cr, t_end - t_begin)
  ratchet_guarantee = max(A_t[slice(int(t_begin/dt), int(t_end/dt), int(1/dt))])

  guarantee = max(accum_guarantee, ratchet_guarantee)
  rider_val = - max(guarantee - A_t[int(t_end/dt)], 0) * val_end

  return inflow + rider_val, A_t, val_end

# print(vec_rollforward(world_args, *vec_roll_args))
# print(vec_GMAB(world_args, *vec_GMAB_args))
# print(vec_GMAB_ratchet(world_args, *vec_GMAB_args))

'''PORTFOLIOS'''
# portfolio is a collection of contracts. just returns the sum of the values of the contracts
def make_portfolio(contracts_and_argses):
    # takes a bunch of contracts and spits out the sum of their values
    def portfolio(world_args):
        t_now, t_max, dt, r, sig2, eZ, S0, S = set_world(world_args)
        
        val = 0
        A_sum = np.zeros(int(t_max/dt)+1)
        for contract, arg in contracts_and_argses:
            this_val, this_A, na = contract(world_args, *arg)
            val += this_val
            A_sum +=this_A
        return val, A_sum, None
    
    return portfolio


'''GREEKS'''

# @numba.njit()
def delta(world_args, bump_size, contract, *args):
  # (t_now, t_max, dt, r, sig2, eZ, ...)

  t_now, t_max, dt, r, sig2, eZ, S0, S = set_world(world_args)
  
  eZ_up = eZ * 1
  eZ_up[int(t_now/dt)] *= 1 + bump_size/2
  S_up = S * 1
  S_up[int(t_now/dt):] *= 1 + bump_size/2

  up_args = t_now, t_max, dt, r, sig2, eZ_up, S0, S_up
  
  # print(len(r))
  # print(len(eZ_up))
  # print(len(S_up))

  
  value_up, na1, na2 = contract(up_args, *args)

  eZ_down = eZ * 1
  eZ_down[int(t_now/dt)] *= 1 - bump_size/2
  S_down = S * 1
  S_down[int(t_now/dt):] *= 1 - bump_size/2

  down_args = t_now, t_max, dt, r, sig2, eZ_down, S0, S_down
  value_down, na1, na2 = contract(down_args, *args)

  return (value_up - value_down) / bump_size, None, None

# @numba.njit()
def rho(world_args, bump_size, contract, *args):

  # print(contract, bump_size, bump_length, world_args, args)

  t_now, t_max, dt, r, sig2, eZ, S0, S = set_world(world_args)

  bump = np.zeros(int(t_max/dt))
  bump[int(t_now/dt):] += bump_size
    
  r_up = r + bump
  eZ_up = eZ * np.exp(bump * dt)
  up_args = set_world((t_now, t_max, dt, r_up, sig2, eZ_up, S0, None))
  
  value_up, na1, na2 = contract(up_args, *args)
  
  r_down = r - bump
  eZ_down = eZ * np.exp(-bump * dt)
  down_args = set_world((t_now, t_max, dt, r_down, sig2, eZ_down, S0, None))
  value_down, na1, na2 = contract(down_args, *args)

  return (value_up - value_down) / bump_size, None, None

# print(delta(world_args, .01, rollforward, *roll_args))
# print(rho(world_args, .01, t_max, GMAB, *GMAB_args))
# print(delta(world_args, .01, delta, .01, GMAB_ratchet, *GMAB_ratchet_args))
# print(delta(world_args, .01, rho, .01, t_max, vec_rollforward, *vec_roll_args))
# print(rho(world_args, .01, t_max, delta, .01, vec_GMAB, *vec_GMAB_args))
# print(rho(world_args, .01, t_max, rho, .01, t_max, vec_GMAB_ratchet, *vec_GMAB_ratchet_args))

# etc

'''QUANTITY (CONTRACT VALUE, GREEK) ESTIMATION'''

# The function value_by_rep takes [0] a tuple of external parameters, [1] a number of iterations to simulate the value of [2] a contract with [3] given arguments.
# The function value_by_error takes [0] a tuple of external parameters, [1] a standard deviation size for the estimate of [2] a contract with [3] given arguments.
# The function value_byprecision takes [0] a tuple of external parameters, [1] a confidence level C, [2] a precision P, [3] a contract and [4] its arguments. Given C=.95 and P=.01 This function simulates the value until the 95% confidence interval for the value is within 1% of the estimated value.
# Value functions return a "sample datum", which is a tuple of external parameters [0] stock value and [1] risk-free interest rate,
#         [2] a type of quantity (present value, delta, rho, etc) [3] MC-estimated value for the quatity under the given external params,
#         [4] the standard deviation of the sample distribution for the estimated quantity and
#         [5] the number of samples of the contract or greek required to produce that precision

# currently, value functions just return [3], [4], [5]

def make_future_gen(world_args, N = None):
  t_now, t_max, dt, r, sig2, eZ, S0, S = world_args
  no_hist = True if eZ is None else False
  count = 0

  while N is None or count < N :
    count += 1
    if no_hist:
      yield set_world(world_args)
    else:
      low_index = int(t_now/dt)+1
      high_index = int(t_max/dt)
      fut_Z = np.random.standard_normal(high_index - low_index)
      fut_eZ = np.exp((r[low_index:high_index]-sig2/2) * dt +  math.sqrt(sig2*dt) * fut_Z)
      
      neZ = eZ * 1  # issues with mutability
      neZ[low_index : high_index] = fut_eZ
     
      yield t_now, t_max, dt, r, sig2, neZ, S0, S
    

def value_by_rep(world_args, N, contract, *args):
  future_gen = make_future_gen(world_args, N)
  samp = [contract(future_world, *args)[0] for future_world in future_gen]

  std = np.std(samp)
  return np.mean(samp), std/np.sqrt(N), N


def value_by_error(world_args, target_std, contract, *args):
  big_N = 1000
  N_list = [big_N]

  # collect base sample, record initial stats
  future_gen = make_future_gen(world_args, big_N)
  samp = np.array([contract(future_world, *args)[0] for future_world in future_gen])

  s_mean = np.mean(samp)
  mean_list = [s_mean]
  std_list = [np.std(samp)]
  var = np.var(samp)
  var_list = [var]

  # adjusted standard deviation
  samp_dist_std = std_list[0] / math.sqrt(N_list[0])
  
  while target_std < samp_dist_std:
    N_tot =  var / target_std**2
    # estimate the number needed to get 
    
    N = int((N_tot - big_N) * 1.1 + 1)
    print('estimated', N, 'more to go')
    N_list.append(N)
    
    # collect new sample and stats
    future_gen = make_future_gen(world_args, N)
    samp = np.array([contract(future_world, *args)[0] for future_world in future_gen])

    mean_list.append(np.mean(samp))
    std_list.append(np.std(samp))
    var_list.append(np.var(samp))

    # update mean and adjusted standard deviation
    big_N = sum(N_list)
    s_mean = sum(map(op.mul, N_list, mean_list)) / big_N
    
    #compute combined variance
    #sorry this is so long it was more readable before i tried to incorporate numba but now it's humongous and i didn't even get any performance benefit out of it
    var = ( sum(map(op.mul, N_list, var_list)) + sum(map(op.mul, N_list, map(op.pow, map(op.sub, mean_list, [s_mean]*len(mean_list)), [2]*len(mean_list)))) ) / big_N
    samp_dist_std = math.sqrt(var) / math.sqrt(big_N)

  # pool.close()
  # pool.join()
  return s_mean, samp_dist_std, big_N


# value(contract, .95, .01) returns an estimate for the value of contract
# whose 95% confidence interval is contained within 1% of the value of the estimated mean
# sample sizes are large enough to skip the student t stuff
# @numba.jit()
def value_by_precision(world_args, confidence, precision, contract, *args):

  # number of standard deviations to cover confidence interval
  tolerated_std = st.norm.ppf((confidence+1)/2)

  big_N = 1000
  N_list = [big_N]
  # pool = mp.Pool(processes=4)

  # collect base sample, record initial stats
  future_gen = make_future_gen(world_args, big_N)
  samp = np.array([contract(future_world, *args)[0] for future_world in future_gen])
  # print(samp)
  s_mean = np.mean(samp)
  mean_list = [s_mean]
  std_list = [np.std(samp)]
  var = np.var(samp)
  var_list = [var]

  # adjusted standard deviation
  rel_std = abs(std_list[0] / (mean_list[0] * math.sqrt(N_list[0])))
  
  while precision < rel_std * tolerated_std:
    N_tot = var * tolerated_std**2 / (precision * s_mean)**2
    # estimate the number needed to get precision
    N = int((N_tot - big_N) * 1.1 + 1)
    print('estimated', N, 'more to go')
    N_list.append(N)
    
    # collect new sample and stats
    future_gen = make_future_gen(world_args, N)
    samp = np.array([contract(future_world, *args)[0] for future_world in future_gen])

    mean_list.append(np.mean(samp))
    std_list.append(np.std(samp))
    var_list.append(np.var(samp))

    # update mean and adjusted standard deviation
    big_N = sum(N_list)
    s_mean = sum(map(op.mul, N_list, mean_list)) / big_N
    
    #compute combined variance
    #sorry this is so long it was more readable before i tried to incorporate numba but now it's humongous and i didn't even get any performance benefit out of it
    var = ( sum(map(op.mul, N_list, var_list)) + sum(map(op.mul, N_list, map(op.pow, map(op.sub, mean_list, [s_mean]*len(mean_list)), [2]*len(mean_list)))) ) / big_N
    rel_std = abs(math.sqrt(var) / (s_mean * math.sqrt(big_N)))

  # pool.close()
  # pool.join()
  return s_mean, abs(s_mean * rel_std), big_N

# print(value_by_rep(world_args, 10, rollforward, *roll_args))
# print(value_by_error(world_args, .01, GMAB, *GMAB_args))
# print(value_by_precision(world_args, .9, .05, GMAB_ratchet, *GMAB_ratchet_args))
# print(value_by_rep(world_args, 10, vec_rollforward, *vec_roll_args))
# print(value_by_error(world_args, .01, vec_GMAB, *vec_GMAB_args))
# print(value_by_precision(world_args, .9, .05, vec_GMAB_ratchet, *vec_GMAB_ratchet_args))

# print(value_by_rep(world_args, 10, delta, .01, GMAB_ratchet, *GMAB_ratchet_args))
# print(value_by_rep(world_args, 10, rho, .01, t_max, GMAB_ratchet, *GMAB_ratchet_args))

def bump_S(world_args, bump_size):
  t_now, t_max, dt, r, sig2, eZ, S0, S = world_args
  
  eZ_bump = eZ * 1
  eZ_bump[int(t_now/dt)] *= 1 + bump_size
  
  return t_now, t_max, dt, r, sig2, eZ_bump, S0, None

def bump_r(world_args, bump_size):
  t_now, t_max, dt, r, sig2, eZ, S0, S = world_args

  bump = np.zeros(int(t_max/dt))
  bump[int(t_now/dt):] += bump_size

  eZ_bump = eZ * np.exp(bump * dt)
  r_bump = r + bump
  
  return t_now, t_max, dt, r_bump, sig2, eZ_bump, S0, None

def shock_value(world_args, shocks, valuation, *valuation_args):
  quant_name = ''
  for arg in valuation_args:
    if type(arg) == types.FunctionType:
      quant_name += arg.__name__ + '_'
  world = set_world(world_args)

  data = []
  count = 0
  for pair in shocks:
    S_bump = pair[0]
    r_bump = pair[1]
    bump_world_1 = bump_S(world, S_bump)
    bump_world_2 = bump_r(bump_world_1, r_bump)
    bump_world_3 = set_world(bump_world_2)
    data.append((pair, quant_name, valuation(bump_world_3, *valuation_args)))
    count += 1
    # print(eZ[int(t_now/dt)], r[int(t_now/dt)])

  return data

def write_shock_data(world, shocks, filename):
  with open(filename, 'w', newline='') as file:
    writer = csv.writer(file)
    csv_world = list(map(lambda a : list(a) if type(a)==np.ndarray
                             else 'None' if a is None else a, world))
    writer.writerow(csv_world)
    for shock in shocks:
      writer.writerow([shock])

def read_shock_data(filename):
  with open(filename, 'r') as file:
    reader = csv.reader(file)
    world = tuple(map(lambda r : np.array(r) if type(r) is list
                          else r, map(literal_eval, next(reader))))
    shock_data = list(map(lambda d : literal_eval(d[0]), reader))
  return((world, shock_data))

# world = 0, t_max, dt, r, sig2, eZ, S0
# value_by_rep(world, 1000, delta, .001, GMAB_ratchet, *GMAB_ratchet_args)

# world = 5-dt, t_max, dt, r, sig2, eZ, S0, None
# shocks = [(0,0), (0,0), (0,0)]
# shock_value(world, shocks, value_by_rep, 10, delta, .001, delta, .001, GMAB_ratchet, *GMAB_ratchet_args)

# world = 5-dt, t_max, dt, r, sig2, eZ, S0
# shocks = [(0,0),(.01,.01),(.03,.01),(.05,.01),(.07,.01),
#           (.01,-.01),(.03,-.01),(.05,-.01),(.07,-.01),
#           (-.01,.01),(-.03,.01),(-.05,.01),(-.07,.01),
#           (-.01,-.01),(-.03,-.01),(-.05,-.01),(-.07,-.01)]
# shock_value(world, shocks, value_by_rep, 10000, delta, .001, GMAB_ratchet, *GMAB_ratchet_args)

# for j in range(0,int(t_max/dt),8):
#     world = (j*dt, t_max, dt, r, sig2, eZ, S0)
#     print(j,value_by_error(world, .01, delta, .01, GMAB_ratchet, *GMAB_ratchet_args))

